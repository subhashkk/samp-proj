var async = require('async');
var chokidar = require('chokidar');
var setStatus = require('../set-status.js');
var c = require('../constants.js');

module.exports = function watch(config, lager$, queue$) {
    var watched = [];

    if (config.watch) {
        chokidar.watch('src/**/*')
            .on('change', function (filePath) {
                deferWatch(filePath);
            });
    }

    var paths = [];
    var timeout;

    function deferWatch(filePath) {
        if (timeout) {
            clearTimeout(timeout);
        }

        paths.push(filePath);

        setTimeout(function () {
            async.concat(paths.filter(unique), normalize, function (err, files) {
                queue$.push(files.reduce(function (accum, file) {
                    return accum.concat(locate(file, watched))
                }, []).filter(unique));
            });
            paths = [];
        }, 1000);
    }

    function normalize(file, done) {
        config.jspm.normalize(file).then(function (normalized) {
            done(null, normalized);
        })
    }

    return function (bundleCfg, done) {
        async.waterfall([
            async.constant(bundleCfg),
            setStatus(c.S_WATCHING, lager$),
            function (bundleCfg, next) {
                if (!~watched.indexOf(bundleCfg)) {
                    watched.push(bundleCfg);
                }

                async.concat(bundleCfg.modules, function (file, nextFile) {
                    config.jspm.normalize(file).then(function (normalized) {
                        nextFile(null, normalized);
                    }, function (err) {
                        nextFile(err);
                    })
                }, function (err, files) {
                    if (err) {
                        throw err;
                    }

                    bundleCfg.watch = files;
                    next(null, bundleCfg);
                });
            }
        ], done);
    }
};

function unique(value, index, self) {
    return self.indexOf(value) === index;
}

function locate(needle, haystack) {
    return haystack.filter(function (bundleCfg) {
        return !!~bundleCfg.watch.indexOf(needle);
    });
}
